# TLSNotary Verifier Server

The TLSNotary Verifier Server is a Rust-based HTTP/WebSocket server that acts as the **verifier party** in Multi-Party Computation TLS (MPC-TLS) protocol. It validates cryptographic proofs generated by the browser extension without ever seeing the user's private data.

## Table of Contents

- [Why a Verifier Server?](#why-a-verifier-server)
- [Architecture Overview](#architecture-overview)
- [Built-in WebSocket Proxy](#built-in-websocket-proxy)
- [API Endpoints](#api-endpoints)
- [Session Flow](#session-flow)
- [Webhook System](#webhook-system)
- [Deployment](#deployment)
- [Configuration](#configuration)
- [Development](#development)

---

## Why a Verifier Server?

TLSNotary uses **Multi-Party Computation (MPC)** to generate cryptographic proofs of TLS data. This requires **two parties**:

1. **Prover** (Browser Extension) - The user generating the proof
2. **Verifier** (This Server) - An independent party that validates the proof

### What the Verifier Does

- **Participates in MPC-TLS Handshake**: The verifier co-signs the TLS handshake without seeing plaintext data
- **Validates Transcript Integrity**: Ensures the HTTP request/response hasn't been tampered with
- **Generates Proof**: Creates cryptographic proof that specific data came from a genuine TLS connection
- **Forwards Requests**: Acts as a WebSocket proxy to forward TLS traffic to target servers

### What the Verifier Does NOT See

- **User Credentials**: Authentication tokens, cookies, API keys remain encrypted to the verifier
- **Hidden Data**: Only data marked with `action: 'REVEAL'` in handlers is visible to the verifier
- **Committed Data**: Data marked with `action: 'PEDERSEN'` is sent as a hash commitment, not plaintext

This architecture allows users to prove data authenticity **without revealing sensitive information** to the verifier.

---

## Architecture Overview

```
┌─────────────────┐                  ┌──────────────────┐                  ┌─────────────────┐
│                 │                  │                  │                  │                 │
│  Browser        │ ◄──WebSocket──►  │  Verifier Server │ ◄──TCP/TLS──►    │  Target Server  │
│  Extension      │                  │  (packages/      │                  │  (api.x.com,    │
│  (Prover)       │                  │   verifier)      │                  │   etc.)         │
│                 │                  │                  │                  │                 │
└────────┬────────┘                  └────────┬─────────┘                  └─────────────────┘
         │                                     │
         │                                     │
         ├─1. /session ───────────────►        │
         │   (create session)                  │
         │                                     │
         ◄─ sessionId ────────────────         │
         │                                     │
         ├─2. /verifier?sessionId=... ────►    │
         │   (MPC-TLS verification)            │
         │                                     │
         │                          3. /proxy?token=api.x.com ─────►
         │                             (forward request to target)
         │                                     │
         ◄─ Proof Result ─────────────         │
         │                                     │
         │                          4. Webhook (optional) ─────► External Service
         │                             (send proof data)
```

### Key Components

1. **Session Management**: Thread-safe HashMap stores session configuration
2. **WebSocket Endpoints**: Three endpoints (`/session`, `/verifier`, `/proxy`) handle different aspects of the protocol
3. **MPC-TLS Verification**: Uses `tlsn` crate for cryptographic verification
4. **Built-in Proxy**: WebSocket-to-TCP bridge forwards requests to target servers
5. **Webhook System**: Fire-and-forget POST notifications with redacted transcripts

---

## Built-in WebSocket Proxy

The verifier includes a **built-in WebSocket proxy** that eliminates the need for external proxy services like `notary.pse.dev`.

### How It Works

The proxy bridges **WebSocket connections** from the browser to **TCP/TLS connections** to target servers:

```
Browser Extension ──► WebSocket ──► Verifier Proxy ──► TCP/TLS ──► api.x.com
```

### Proxy Endpoint

**WebSocket** `/proxy?token=<host>`

**Query Parameters:**
- `token` (required) - Target server hostname (e.g., `api.x.com`, `api.github.com`)

**Alternative (legacy):**
- `host` (deprecated) - Same as `token`, supported for backward compatibility

**Protocol:**
- Local development: `ws://localhost:7047/proxy?token=api.x.com`
- Production: `wss://demo.tlsnotary.org/proxy?token=api.x.com`

### Example Usage

```javascript
// Create WebSocket connection to proxy
const proxyUrl = 'ws://localhost:7047/proxy?token=api.x.com';
const ws = new WebSocket(proxyUrl);

// Send HTTP request bytes through WebSocket
ws.onopen = () => {
  const httpRequest = 'GET /1.1/account/settings.json HTTP/1.1\r\n' +
                      'Host: api.x.com\r\n' +
                      'Connection: close\r\n\r\n';
  ws.send(httpRequest);
};

// Receive HTTP response bytes
ws.onmessage = (event) => {
  console.log('Response:', event.data);
};
```

### Proxy Implementation Details

The proxy implementation:
- **Parses hostname and port** from the `token` parameter (defaults to port 443 for HTTPS)
- **Establishes TCP connection** to the target server
- **Bidirectional bridge**: WebSocket ↔ TCP
  - WebSocket messages → TCP stream
  - TCP stream → WebSocket messages
- **Automatic cleanup**: Closes connections when either side disconnects
- **Logging**: Tracks total bytes forwarded for debugging

**Source:** `packages/verifier/src/main.rs` (`proxy_ws_handler` and `handle_proxy_connection`)

---

## API Endpoints

### 1. Health Check

**GET** `/health`

Simple endpoint for monitoring and load balancer health checks.

**Response:**
```
ok
```

**Example:**
```bash
curl http://localhost:7047/health
```

---

### 2. Create Session

**WebSocket** `/session`

Creates a new MPC-TLS verification session. The extension connects to this endpoint to initiate the verification protocol.

**WebSocket Message (JSON):**
```json
{
  "maxRecvData": 16384,
  "maxSentData": 4096,
  "sessionData": {
    "userId": "user_123",
    "purpose": "twitter_verification"
  }
}
```

**Parameters:**
- `maxRecvData` (number, optional) - Maximum bytes the prover can receive (default: 16384)
- `maxSentData` (number, optional) - Maximum bytes the prover can send (default: 4096)
- `sessionData` (object, optional) - Custom key-value metadata for this session
  - Stored with the session and included in webhook notifications
  - Useful for tracking user IDs, request IDs, or application context
  - Example: `{ userId: '123', requestId: 'req_abc', purpose: 'account_verification' }`

**WebSocket Response (JSON):**
```json
{
  "sessionId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Example (JavaScript):**
```javascript
const ws = new WebSocket('ws://localhost:7047/session');

ws.onopen = () => {
  ws.send(JSON.stringify({
    maxRecvData: 16384,
    maxSentData: 4096,
    sessionData: { userId: 'user_123', purpose: 'twitter_verification' }
  }));
};

ws.onmessage = (event) => {
  const { sessionId } = JSON.parse(event.data);
  console.log('Session ID:', sessionId);
  // Use sessionId to connect to /verifier
};
```

**Session Lifecycle:**
1. Extension opens WebSocket to `/session`
2. Extension sends configuration (maxRecvData, maxSentData, sessionData)
3. Server generates UUID, stores session configuration
4. Server responds with `sessionId`
5. Extension keeps WebSocket open (used for prover communication)
6. Extension opens second WebSocket to `/verifier?sessionId=<id>`
7. Server validates sessionId, spawns verification task
8. After verification completes, session is cleaned up

---

### 3. Verifier Connection

**WebSocket** `/verifier?sessionId=<session-id>`

Connects to an existing session as the verifier party in MPC-TLS. This endpoint:
- Validates the `sessionId` exists
- Retrieves session configuration (maxRecvData, maxSentData, sessionData)
- Spawns MPC-TLS verification task
- Returns redacted transcripts and proof data
- Cleans up session after completion

**Query Parameters:**
- `sessionId` (required) - Session ID from `/session` endpoint

**Error Responses:**
- `404 Not Found` - Session ID doesn't exist or was already used
- `500 Internal Server Error` - Verification failed

**WebSocket Messages:**
The verifier receives binary TLS messages from the prover and responds with verification data. Message format is defined by the TLSNotary protocol.

**Example (JavaScript):**
```javascript
const sessionId = '550e8400-e29b-41d4-a716-446655440000';
const ws = new WebSocket(`ws://localhost:7047/verifier?sessionId=${sessionId}`);

ws.onmessage = (event) => {
  // Verification result (binary or JSON depending on protocol phase)
  console.log('Verification data received');
};

ws.onclose = () => {
  console.log('Verification complete, session cleaned up');
};
```

**Implementation Notes:**
- Session configuration (maxRecvData, maxSentData) is passed to the TLSNotary prover configuration
- The `sessionData` object is passed to the verification task for webhook inclusion
- Sessions are single-use and automatically removed after the WebSocket closes
- Thread-safe storage using `Arc<Mutex<HashMap>>` allows concurrent sessions

---

### 4. WebSocket Proxy

**WebSocket** `/proxy?token=<host>`

Forwards WebSocket traffic to target servers via TCP/TLS. See [Built-in WebSocket Proxy](#built-in-websocket-proxy) section for details.

---

## Session Flow

Complete flow for generating a TLS proof:

```
┌─────────────────┐                  ┌──────────────────┐                  ┌─────────────────┐
│  Extension      │                  │  Verifier Server │                  │  Target Server  │
└────────┬────────┘                  └────────┬─────────┘                  └────────┬────────┘
         │                                     │                                     │
         │  1. WS /session                     │                                     │
         │ ──────────────────────────────────► │                                     │
         │                                     │                                     │
         │  2. { sessionId: "..." }            │                                     │
         │ ◄────────────────────────────────── │                                     │
         │                                     │                                     │
         │  3. WS /verifier?sessionId=...      │                                     │
         │ ──────────────────────────────────► │                                     │
         │                                     │                                     │
         │  4. Prover sends request via MPC    │  5. WS /proxy?token=api.x.com       │
         │ ──────────────────────────────────► │ ──────────────────────────────────► │
         │                                     │                                     │
         │                                     │  6. TCP: HTTP request               │
         │                                     │ ──────────────────────────────────► │
         │                                     │                                     │
         │                                     │  7. TCP: HTTP response              │
         │                                     │ ◄────────────────────────────────── │
         │                                     │                                     │
         │  8. Verifier validates transcript   │                                     │
         │ ◄────────────────────────────────── │                                     │
         │                                     │                                     │
         │  9. Proof result with redacted data │                                     │
         │ ◄────────────────────────────────── │                                     │
         │                                     │                                     │
         │                                     │  10. Webhook POST (optional)        │
         │                                     │ ──────────────────────────────────► Backend
         │                                     │                                     │
         │  11. WS close, session cleanup      │                                     │
         │ ◄────────────────────────────────── │                                     │
         │                                     │                                     │
```

**Detailed Steps:**

1. **Session Creation**: Extension opens WebSocket to `/session`, sends maxRecvData/maxSentData/sessionData
2. **Session ID**: Server generates UUID, stores config, returns sessionId to extension
3. **Verifier Connection**: Extension opens second WebSocket to `/verifier?sessionId=<id>`
4. **MPC-TLS Handshake**: Extension (prover) and server (verifier) perform MPC-TLS handshake
5. **Proxy Connection**: Server opens WebSocket to `/proxy?token=<target-host>` to forward request
6. **Request Forwarding**: Proxy forwards HTTP request bytes to target server via TCP
7. **Response Forwarding**: Proxy receives HTTP response from target server, sends back to prover
8. **Transcript Validation**: Verifier validates TLS transcript, applies selective disclosure handlers
9. **Proof Generation**: Server returns proof with redacted transcript (only revealed ranges visible)
10. **Webhook Notification** (optional): Server sends POST to configured webhook with proof data
11. **Cleanup**: WebSocket closes, session is removed from memory

---

## Webhook System

The verifier can send proof data to external services via HTTP POST webhooks. This enables integration with backend systems for proof verification, storage, or business logic.

### Configuration

Webhooks are configured in `config.yaml`:

```yaml
webhooks:
  # Per-server webhooks (matched by target hostname)
  "api.x.com":
    url: "https://your-backend.example.com/webhook/twitter"
    headers:
      Authorization: "Bearer your-secret-token"
      X-Source: "tlsn-verifier"
      Content-Type: "application/json"

  "api.github.com":
    url: "https://your-backend.example.com/webhook/github"
    headers:
      Authorization: "Bearer another-token"

  # Wildcard: catch-all for any unmatched server
  "*":
    url: "https://your-backend.example.com/webhook/default"
    headers:
      X-Source: "tlsn-verifier"
```

**Matching Logic:**
1. Server extracts target hostname from the HTTP request (e.g., `api.x.com`)
2. Looks for exact match in webhook configuration
3. If no exact match, falls back to wildcard `"*"` if configured
4. If no webhook configured, skips notification (no error)

### Webhook Payload

**HTTP Method:** `POST`

**Content-Type:** `application/json`

**Payload Structure:**
```json
{
  "sessionId": "550e8400-e29b-41d4-a716-446655440000",
  "sessionData": {
    "userId": "user_123",
    "requestId": "req_abc",
    "purpose": "account_verification"
  },
  "server_name": "api.x.com",
  "redactedTranscript": {
    "sent": "R0VUIC8xLjEvYWNjb3VudC9zZXR0aW5ncy5qc29uIEhUVFAvMS4xDQpIb3N0OiBhcGkueC5jb20NCg==",
    "recv": "SFRUUC8xLjEgMjAwIE9LDQpDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb24NCg0KeyJzY3JlZW5fbmFtZSI6InRlc3RfdXNlciJ9"
  },
  "revealConfig": [
    { "type": "SENT", "part": "START_LINE", "action": "REVEAL" },
    { "type": "RECV", "part": "BODY", "action": "REVEAL", "params": { "type": "json", "path": "screen_name" } }
  ]
}
```

**Fields:**
- `sessionId` (string) - UUID of the verification session
- `sessionData` (object) - Custom metadata passed during session creation
- `server_name` (string) - Target server hostname (e.g., `api.x.com`)
- `redactedTranscript` (object) - Base64-encoded HTTP transcripts
  - `sent` (string) - Sent data (request) with redactions applied
  - `recv` (string) - Received data (response) with redactions applied
  - **Only revealed ranges are visible** - hidden data is replaced with null bytes or omitted
- `revealConfig` (array) - Handler configuration showing what was revealed

**Important:** The `redactedTranscript` contains **only the data marked as revealed** in the handlers. Data with `action: 'PEDERSEN'` or unmarked data is **not included** in the transcript.

### Example Backend Handler

```javascript
// Express.js webhook endpoint
app.post('/webhook/twitter', async (req, res) => {
  const { sessionId, sessionData, server_name, redactedTranscript, revealConfig } = req.body;

  // Decode base64 transcripts
  const sentData = Buffer.from(redactedTranscript.sent, 'base64').toString('utf-8');
  const recvData = Buffer.from(redactedTranscript.recv, 'base64').toString('utf-8');

  console.log('Received proof for session:', sessionId);
  console.log('User ID:', sessionData.userId);
  console.log('Server:', server_name);
  console.log('Revealed request:', sentData);
  console.log('Revealed response:', recvData);

  // Validate proof, extract data, update database, etc.
  await db.proofs.insert({
    sessionId,
    userId: sessionData.userId,
    server: server_name,
    sentData,
    recvData,
    timestamp: new Date()
  });

  res.status(200).json({ received: true });
});
```

### Fire-and-Forget Behavior

Webhooks are sent **asynchronously** and do **not** block the verification process:
- Sent in a separate `tokio::spawn` task
- Errors are logged but do not affect the proof result
- No retry logic (single attempt per proof)
- Timeout: Default HTTP client timeout (typically 30 seconds)

**Implication:** If your webhook endpoint is down or slow, the proof will still succeed. Check verifier logs for webhook errors.

### Security Considerations

1. **HTTPS Only (Production)**: Always use `https://` URLs for webhooks in production
2. **Authentication**: Include `Authorization` headers to verify webhook origin
3. **Signature Verification**: Consider implementing HMAC signatures for payload validation
4. **Idempotency**: Webhooks may be retried in future versions, design endpoints to be idempotent
5. **Rate Limiting**: Implement rate limiting on webhook endpoints to prevent abuse

---

## Deployment

### Local Development

```bash
cd packages/verifier

# Run in development mode
cargo run

# Server starts on http://0.0.0.0:7047
```

### Production Build

```bash
# Build optimized binary
cargo build --release

# Binary location: target/release/tlsn-verifier-server
./target/release/tlsn-verifier-server
```

### Docker Deployment

**Dockerfile:**
```dockerfile
FROM rust:1.75 AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# Build release binary
RUN cargo build --release

# Runtime stage
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/tlsn-verifier-server /usr/local/bin/
COPY config.yaml /etc/tlsn-verifier/config.yaml

ENV RUST_LOG=info

EXPOSE 7047

CMD ["tlsn-verifier-server"]
```

**Build and Run:**
```bash
docker build -t tlsn-verifier-server .
docker run -p 7047:7047 -v $(pwd)/config.yaml:/etc/tlsn-verifier/config.yaml tlsn-verifier-server
```

### Environment Variables

- `RUST_LOG` - Logging level (`trace`, `debug`, `info`, `warn`, `error`)
  - Example: `RUST_LOG=info cargo run`
  - Default: `info`

### Reverse Proxy (nginx)

For production deployments behind nginx:

```nginx
upstream tlsn_verifier {
    server localhost:7047;
}

server {
    listen 443 ssl http2;
    server_name demo.tlsnotary.org;

    ssl_certificate /etc/letsencrypt/live/demo.tlsnotary.org/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/demo.tlsnotary.org/privkey.pem;

    # WebSocket endpoints
    location ~ ^/(session|verifier|proxy|health) {
        proxy_pass http://tlsn_verifier;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Long timeout for MPC-TLS operations
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }
}
```

**Important nginx Settings:**
- `proxy_http_version 1.1` - Required for WebSocket
- `Upgrade` and `Connection` headers - Required for WebSocket upgrade
- `proxy_read_timeout 3600s` - Long timeout for slow MPC operations
- SSL/TLS termination at nginx, plain HTTP to backend

---

## Configuration

### Server Settings

**Location:** `packages/verifier/src/main.rs`

**Default Configuration:**
```rust
let addr = SocketAddr::from(([0, 0, 0, 0], 7047));
```

- **Host:** `0.0.0.0` (all network interfaces)
- **Port:** `7047`

To change the port, modify the `SocketAddr::from()` call or add environment variable support.

### Webhook Configuration

**Location:** `packages/verifier/config.yaml`

See [Webhook System](#webhook-system) section for configuration format.

**Loading Logic:**
- Server attempts to load `config.yaml` from current working directory
- If file not found, webhooks are disabled (no error)
- Invalid YAML syntax causes server startup failure

### CORS Policy

**Current:** Permissive (allows all origins)

**Location:** `packages/verifier/src/main.rs`
```rust
.layer(CorsLayer::permissive())
```

**Production Recommendation:** Restrict CORS to specific origins:
```rust
use tower_http::cors::{CorsLayer, Any};
use http::Method;

let cors = CorsLayer::new()
    .allow_origin("https://demo.tlsnotary.org".parse::<HeaderValue>().unwrap())
    .allow_methods([Method::GET, Method::POST])
    .allow_headers(Any);

let app = Router::new()
    .route(...)
    .layer(cors);
```

### Logging Configuration

Set via `RUST_LOG` environment variable:

```bash
# Info level (recommended for production)
RUST_LOG=info cargo run

# Debug level (detailed logs)
RUST_LOG=debug cargo run

# Trace level (very verbose)
RUST_LOG=trace cargo run
```

**Log Format:**
```
2026-01-20T10:30:45.123456Z  INFO tlsn_verifier_server: Server listening on 0.0.0.0:7047
2026-01-20T10:30:50.234567Z  INFO tlsn_verifier_server: [Session] New session created: 550e8400-e29b-41d4-a716-446655440000
2026-01-20T10:30:51.345678Z  INFO tlsn_verifier_server: [Proxy] New proxy request for host: api.x.com
```

---

## Development

### Project Structure

```
packages/verifier/
├── src/
│   ├── main.rs              # HTTP server, routing, WebSocket handlers
│   ├── verifier.rs          # TLSNotary MPC-TLS verification logic
│   ├── axum_websocket.rs    # WebSocket-to-AsyncRead/Write bridge
│   └── tests/               # Integration tests
├── Cargo.toml               # Rust dependencies
├── Cargo.lock               # Locked dependency versions
├── config.yaml              # Webhook configuration
├── Dockerfile               # Docker build instructions
└── README.md                # Package documentation
```

### Key Dependencies

**Core TLSNotary:**
- `tlsn` v0.1.0-alpha.14 - TLSNotary protocol implementation

**Web Framework:**
- `axum` 0.7 - HTTP server with WebSocket support
- `tower-http` - CORS middleware
- `hyper` - Low-level HTTP library

**WebSocket:**
- `ws_stream_tungstenite` - WebSocket to AsyncRead/AsyncWrite bridge
- `async-tungstenite` - Async WebSocket implementation

**Serialization:**
- `serde`, `serde_json` - JSON serialization
- `serde_yaml` - YAML config parsing

**Async Runtime:**
- `tokio` - Async runtime with full features
- `futures-util` - Async stream utilities

**HTTP Client:**
- `reqwest` - HTTP client for webhooks

**Utilities:**
- `uuid` - Session ID generation
- `tracing` - Structured logging
- `eyre` - Error handling

### Adding New Routes

Add routes in `src/main.rs`:

```rust
let app = Router::new()
    .route("/health", get(health_handler))
    .route("/session", get(session_ws_handler))
    .route("/verifier", get(verifier_ws_handler))
    .route("/proxy", get(proxy_ws_handler))
    .route("/your-route", get(your_handler))  // Add here
    .layer(CorsLayer::permissive())
    .with_state(app_state);
```

### Running Tests

```bash
# Run all tests
cargo test

# Run tests with output
cargo test -- --nocapture

# Run specific test
cargo test test_name
```

### Testing with Extension

1. **Start verifier server:**
   ```bash
   cd packages/verifier
   RUST_LOG=debug cargo run
   ```

2. **Build and load extension:**
   ```bash
   cd packages/extension
   npm run dev
   # Load extension in Chrome from packages/extension/build/
   ```

3. **Open DevConsole:**
   - Right-click extension icon → "Developer Console"
   - Paste plugin code
   - Click "Execute"

4. **Check verifier logs:**
   ```
   [Session] New session created: 550e8400-...
   [Proxy] New proxy request for host: api.x.com
   [550e8400] Connecting to api.x.com:443
   [550e8400] Successfully proxied 1234 bytes
   Verification complete
   ```

### Debugging WebSocket Connections

Use `websocat` for manual WebSocket testing:

```bash
# Install websocat
cargo install websocat

# Test health endpoint
curl http://localhost:7047/health

# Test session creation
websocat ws://localhost:7047/session
# Send: {"maxRecvData": 16384, "maxSentData": 4096}
# Receive: {"sessionId": "550e8400-..."}

# Test proxy
websocat ws://localhost:7047/proxy?token=api.x.com
# Send HTTP request bytes
# Receive HTTP response bytes
```

### Common Issues

**Issue:** `Address already in use (os error 48)`
**Solution:** Port 7047 is already bound. Kill existing process:
```bash
lsof -ti:7047 | xargs kill -9
```

**Issue:** `failed to load config.yaml`
**Solution:** Create `config.yaml` or run from directory containing it:
```bash
cd packages/verifier
cargo run
```

**Issue:** WebSocket upgrade fails
**Solution:** Ensure client sends `Upgrade: websocket` and `Connection: Upgrade` headers

**Issue:** Proxy connection timeout
**Solution:** Check target server is reachable:
```bash
nc -zv api.x.com 443
```

---

## Integration with Browser Extension

The browser extension (`packages/extension`) integrates with the verifier through the `@tlsn/plugin-sdk` package.

### Extension → Verifier Flow

**In `packages/extension/src/offscreen/SessionManager.ts`:**

```typescript
import Host from '@tlsn/plugin-sdk';

const host = new Host({
  onProve: async (requestOptions, proverOptions) => {
    // 1. Create session
    const sessionWs = new WebSocket('ws://localhost:7047/session');
    sessionWs.send(JSON.stringify({
      maxRecvData: proverOptions.maxRecvData,
      maxSentData: proverOptions.maxSentData,
      sessionData: proverOptions.sessionData
    }));

    // 2. Receive sessionId
    const { sessionId } = await waitForMessage(sessionWs);

    // 3. Connect verifier
    const verifierWs = new WebSocket(`ws://localhost:7047/verifier?sessionId=${sessionId}`);

    // 4. Perform MPC-TLS handshake, get proof
    const proof = await performMpcTls(sessionWs, verifierWs, requestOptions, proverOptions);

    return proof;
  }
});
```

### Plugin → Verifier Flow

**In plugin code:**

```javascript
const proof = await prove(
  {
    url: 'https://api.x.com/1.1/account/settings.json',
    method: 'GET',
    headers: { /* ... */ }
  },
  {
    verifierUrl: 'http://localhost:7047',
    proxyUrl: 'ws://localhost:7047/proxy?token=api.x.com',
    maxRecvData: 16384,
    maxSentData: 4096,
    sessionData: { userId: '123', purpose: 'twitter_verification' },
    handlers: [
      { type: 'RECV', part: 'BODY', action: 'REVEAL', params: { type: 'json', path: 'screen_name' } }
    ]
  }
);
```

**Verifier processes:**
1. Session creation with sessionData
2. MPC-TLS verification
3. Selective disclosure (only `screen_name` revealed)
4. Webhook notification with redacted transcript
5. Return proof to plugin

---

## Resources

- **TLSNotary Protocol**: [https://docs.tlsnotary.org](https://docs.tlsnotary.org)
- **Axum Documentation**: [https://docs.rs/axum](https://docs.rs/axum)
- **Rust TLSNotary Crate**: [https://github.com/tlsnotary/tlsn](https://github.com/tlsnotary/tlsn)
- **Extension Integration**: See [PLUGIN.md](./PLUGIN.md) for plugin API reference
- **Demo Site**: [https://demo.tlsnotary.org](https://demo.tlsnotary.org)

---

## License

See the root [LICENSE](./LICENSE) file for license information.
